<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
	<title>WGLT - Roguelike Tutorial - Part 12 - Monster and item progression</title>
    <link href="../../styles.css" rel="stylesheet">
</head>

<body>
	<canvas></canvas>
	<p><a href="http://www.roguebasin.com/index.php?title=Complete_Roguelike_Tutorial,_using_python%2Blibtcod,_part_12">Part 12: Monster and item progression</a></p>
	<p>Deeper dungeon levels become increasingly more difficult! Here we create tools for dealing with chances and making them vary with level.</p>
    <div class="diff">
        <!--STARTDIFF--><div class="c3">--- part11.js	2019-02-17 17:09:04.000000000 -0800</div>
<div class="c2">+++ part12.js	2019-01-29 11:52:11.000000000 -0800</div>
<div class="c1">@@ -1,18 +1,24 @@</div>
<div class="c0"> </div>
<div class="c2">+// Actual size of the window</div>
<div class="c2">+const SCREEN_WIDTH = 80;</div>
<div class="c2">+const SCREEN_HEIGHT = 50;</div>
<div class="c2">+</div>
<div class="c0"> // Size of the map</div>
<div class="c3">-const MAP_WIDTH = 60;</div>
<div class="c3">-const MAP_HEIGHT = 40;</div>
<div class="c2">+const MAP_WIDTH = 80;</div>
<div class="c2">+const MAP_HEIGHT = 43;</div>
<div class="c0"> </div>
<div class="c3">-const TILE_SIZE = 16;</div>
<div class="c3">-const TILE_WALL = 1 + 2 * 64 + 0;</div>
<div class="c3">-const TILE_FLOOR = 1 + 2 * 64 + 1;</div>
<div class="c2">+// Sizes and coordinates relevant for the GUI</div>
<div class="c2">+const BAR_WIDTH = 20;</div>
<div class="c2">+const PANEL_HEIGHT = 7;</div>
<div class="c2">+const PANEL_Y = SCREEN_HEIGHT - PANEL_HEIGHT;</div>
<div class="c2">+const MSG_X = BAR_WIDTH + 2;</div>
<div class="c2">+const MSG_WIDTH = SCREEN_WIDTH - BAR_WIDTH - 2;</div>
<div class="c2">+const MSG_HEIGHT = PANEL_HEIGHT - 1;</div>
<div class="c0"> </div>
<div class="c0"> // Parameters for dungeon generator</div>
<div class="c0"> const ROOM_MAX_SIZE = 10;</div>
<div class="c0"> const ROOM_MIN_SIZE = 6;</div>
<div class="c0"> const MAX_ROOMS = 30;</div>
<div class="c3">-const MAX_ROOM_MONSTERS = 3;</div>
<div class="c3">-const MAX_ROOM_ITEMS = 2;</div>
<div class="c0"> const TORCH_RADIUS = 10;</div>
<div class="c0"> </div>
<div class="c0"> // Spell values</div>
<div class="c1">@@ -25,37 +31,251 @@</div>
<div class="c0"> const FIREBALL_RADIUS = 3;</div>
<div class="c0"> const FIREBALL_DAMAGE = 12;</div>
<div class="c0"> </div>
<div class="c2">+// Experience and level-ups</div>
<div class="c2">+const LEVEL_UP_BASE = 200;</div>
<div class="c2">+const LEVEL_UP_FACTOR = 150;</div>
<div class="c2">+</div>
<div class="c2">+const COLOR_DARK_WALL = wglt.fromRgb(0, 0, 100);</div>
<div class="c2">+const COLOR_LIGHT_WALL = wglt.fromRgb(130, 110, 50);</div>
<div class="c2">+const COLOR_DARK_GROUND = wglt.fromRgb(50, 50, 150);</div>
<div class="c2">+const COLOR_LIGHT_GROUND = wglt.fromRgb(200, 180, 50);</div>
<div class="c2">+</div>
<div class="c2">+function Tile(blocked) {</div>
<div class="c2">+    this.blocked = blocked;</div>
<div class="c2">+    this.blockSight = blocked;</div>
<div class="c2">+    this.explored = false;</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function Rect(x, y, w, h) {</div>
<div class="c2">+    this.x1 = x;</div>
<div class="c2">+    this.y1 = y;</div>
<div class="c2">+    this.x2 = x + w;</div>
<div class="c2">+    this.y2 = y + h;</div>
<div class="c2">+</div>
<div class="c2">+    this.getCenter = function () {</div>
<div class="c2">+        return {</div>
<div class="c2">+            x: ((this.x1 + this.x2) / 2) | 0,</div>
<div class="c2">+            y: ((this.y1 + this.y2) / 2) | 0</div>
<div class="c2">+        };</div>
<div class="c2">+    }</div>
<div class="c2">+</div>
<div class="c2">+    this.intersects = function (other) {</div>
<div class="c2">+        return this.x1 &lt;= other.x2 &amp;&amp; this.x2 &gt;= other.x1 &amp;&amp;</div>
<div class="c2">+            this.y1 &lt;= other.y2 &amp;&amp; this.y2 &gt;= other.y1;</div>
<div class="c2">+    }</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function Entity(x, y, char, name, color, blocks, components) {</div>
<div class="c2">+    this.x = x;</div>
<div class="c2">+    this.y = y;</div>
<div class="c2">+    this.char = char;</div>
<div class="c2">+    this.name = name;</div>
<div class="c2">+    this.color = color;</div>
<div class="c2">+    this.blocks = !!blocks;</div>
<div class="c2">+</div>
<div class="c2">+    if (components) {</div>
<div class="c2">+        for (var property in components) {</div>
<div class="c2">+            if (components.hasOwnProperty(property)) {</div>
<div class="c2">+                this[property] = components[property];</div>
<div class="c2">+                this[property].owner = this;</div>
<div class="c2">+            }</div>
<div class="c2">+        }</div>
<div class="c2">+    }</div>
<div class="c2">+</div>
<div class="c2">+    this.move = function (dx, dy) {</div>
<div class="c2">+        if (isBlocked(this.x + dx, this.y + dy)) {</div>
<div class="c2">+            return;</div>
<div class="c2">+        }</div>
<div class="c2">+        this.x += dx;</div>
<div class="c2">+        this.y += dy;</div>
<div class="c2">+    };</div>
<div class="c2">+</div>
<div class="c2">+    this.moveToward = function (targetX, targetY) {</div>
<div class="c2">+        const dx = targetX - this.x;</div>
<div class="c2">+        const dy = targetY - this.y;</div>
<div class="c2">+        const distance = Math.hypot(dx, dy);</div>
<div class="c2">+        this.move(Math.round(dx / distance), Math.round(dy / distance));</div>
<div class="c2">+    };</div>
<div class="c2">+</div>
<div class="c2">+    this.distanceTo = function (other) {</div>
<div class="c2">+        return Math.hypot(other.x - this.x, other.y - this.y);</div>
<div class="c2">+    };</div>
<div class="c2">+</div>
<div class="c2">+    this.distance = function (x, y) {</div>
<div class="c2">+        return Math.hypot(x - this.x, y - this.y);</div>
<div class="c2">+    };</div>
<div class="c2">+</div>
<div class="c2">+    this.sendToBack = function () {</div>
<div class="c2">+        this.remove();</div>
<div class="c2">+        entities.unshift(this);</div>
<div class="c2">+    };</div>
<div class="c2">+</div>
<div class="c2">+    this.remove = function () {</div>
<div class="c2">+        entities.splice(entities.indexOf(this), 1);</div>
<div class="c2">+    };</div>
<div class="c2">+</div>
<div class="c2">+    this.draw = function () {</div>
<div class="c2">+        if (fovMap.isVisible(this.x, this.y)) {</div>
<div class="c2">+            app.drawString(this.x, this.y, this.char, this.color);</div>
<div class="c2">+        }</div>
<div class="c2">+    };</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function Fighter(hp, defense, power, xp, deathFunction) {</div>
<div class="c2">+    this.owner = null;</div>
<div class="c2">+    this.maxHp = hp;</div>
<div class="c2">+    this.hp = hp;</div>
<div class="c2">+    this.defense = defense;</div>
<div class="c2">+    this.power = power;</div>
<div class="c2">+    this.xp = xp;</div>
<div class="c2">+    this.deathFunction = deathFunction || null;</div>
<div class="c2">+</div>
<div class="c2">+    this.attack = function (target) {</div>
<div class="c2">+        const damage = this.power - target.fighter.defense;</div>
<div class="c2">+</div>
<div class="c2">+        if (damage &gt; 0) {</div>
<div class="c2">+            addMessage(capitalize(this.owner.name) + &#x27; attacks &#x27; + target.name + &#x27; for &#x27; + damage + &#x27; hit points.&#x27;);</div>
<div class="c2">+            target.fighter.takeDamage(damage);</div>
<div class="c2">+        } else {</div>
<div class="c2">+            addMessage(capitalize(this.owner.name) + &#x27; attacks &#x27; + target.name + &#x27; but it has no effect!&#x27;);</div>
<div class="c2">+        }</div>
<div class="c2">+    };</div>
<div class="c2">+</div>
<div class="c2">+    this.takeDamage = function (damage) {</div>
<div class="c2">+        this.hp -= damage;</div>
<div class="c2">+</div>
<div class="c2">+        // Check for death. if there&#x27;s a death function, call it</div>
<div class="c2">+        if (this.hp &lt;= 0) {</div>
<div class="c2">+            this.hp = 0;</div>
<div class="c2">+            if (this.deathFunction) {</div>
<div class="c2">+                this.deathFunction(this.owner);</div>
<div class="c2">+            }</div>
<div class="c2">+            if (this.owner !== player) {</div>
<div class="c2">+                player.fighter.xp += this.xp;</div>
<div class="c2">+                checkLevelUp();</div>
<div class="c2">+            }</div>
<div class="c2">+        }</div>
<div class="c2">+    };</div>
<div class="c2">+</div>
<div class="c2">+    this.heal = function (amount) {</div>
<div class="c2">+        this.hp = Math.min(this.hp + amount, this.maxHp);</div>
<div class="c2">+    };</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function BasicMonster() {</div>
<div class="c2">+    this.owner = null;</div>
<div class="c2">+</div>
<div class="c2">+    this.takeTurn = function () {</div>
<div class="c2">+        const monster = this.owner;</div>
<div class="c2">+</div>
<div class="c2">+        // A basic monster takes its turn. if you can see it, it can see you</div>
<div class="c2">+        if (fovMap.isVisible(monster.x, monster.y)) {</div>
<div class="c2">+</div>
<div class="c2">+            if (monster.distanceTo(player) &gt;= 2) {</div>
<div class="c2">+                // Move towards player if far away</div>
<div class="c2">+                monster.moveToward(player.x, player.y);</div>
<div class="c2">+</div>
<div class="c2">+            } else if (player.fighter.hp &gt; 0) {</div>
<div class="c2">+                // Close enough, attack! (if the player is still alive.)</div>
<div class="c2">+                monster.fighter.attack(player);</div>
<div class="c2">+            }</div>
<div class="c2">+        }</div>
<div class="c2">+    };</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function ConfusedMonster(oldAi) {</div>
<div class="c2">+    this.owner = null;</div>
<div class="c2">+    this.oldAi = oldAi;</div>
<div class="c2">+    this.numTurns = CONFUSE_NUM_TURNS;</div>
<div class="c2">+</div>
<div class="c2">+    this.takeTurn = function () {</div>
<div class="c2">+        if (this.numTurns &gt; 0) {</div>
<div class="c2">+            // Still confused...</div>
<div class="c2">+            // Move in a random direction, and decrease the number of turns confused</div>
<div class="c2">+            this.owner.move(rng.nextRange(-1, 1), rng.nextRange(-1, 1));</div>
<div class="c2">+            this.numTurns--;</div>
<div class="c2">+        } else {</div>
<div class="c2">+            this.owner.ai = this.oldAi;</div>
<div class="c2">+            addMessage(&#x27;The &#x27; + this.owner.name + &#x27; is no longer confused!&#x27;, wglt.Colors.LIGHT_RED);</div>
<div class="c2">+        }</div>
<div class="c2">+    }</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function Item(useFunction) {</div>
<div class="c2">+    this.useFunction = useFunction;</div>
<div class="c2">+</div>
<div class="c2">+    this.pickUp = function () {</div>
<div class="c2">+        if (inventory.length &gt;= 26) {</div>
<div class="c2">+            addMessage(&#x27;Your inventory is full, cannot pick up &#x27; + this.owner.name + &#x27;.&#x27;, wglt.Colors.LIGHT_RED);</div>
<div class="c2">+        } else {</div>
<div class="c2">+            inventory.push(this.owner);</div>
<div class="c2">+            this.owner.remove();</div>
<div class="c2">+            addMessage(&#x27;You picked up a &#x27; + this.owner.name + &#x27;!&#x27;, wglt.Colors.LIGHT_GREEN);</div>
<div class="c2">+        }</div>
<div class="c2">+    };</div>
<div class="c2">+</div>
<div class="c2">+    this.use = function () {</div>
<div class="c2">+        if (this.useFunction) {</div>
<div class="c2">+            this.useFunction(this);</div>
<div class="c2">+        } else {</div>
<div class="c2">+            addMessage(&#x27;The &#x27; + this.owner.name + &#x27; cannot be used.&#x27;);</div>
<div class="c2">+        }</div>
<div class="c2">+    };</div>
<div class="c2">+</div>
<div class="c2">+    this.remove = function () {</div>
<div class="c2">+        inventory.splice(inventory.indexOf(this.owner), 1);</div>
<div class="c2">+    };</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function isBlocked(x, y) {</div>
<div class="c2">+    // First test the map tile</div>
<div class="c2">+    if (map[y][x].blocked) {</div>
<div class="c2">+        return true;</div>
<div class="c2">+    }</div>
<div class="c2">+</div>
<div class="c2">+    // Now check for any blocking objects</div>
<div class="c2">+    for (let i = 0; i &lt; entities.length; i++) {</div>
<div class="c2">+        const entity = entities[i];</div>
<div class="c2">+        if (entity.blocks &amp;&amp; entity.x === x &amp;&amp; entity.y === y) {</div>
<div class="c2">+            return true;</div>
<div class="c2">+        }</div>
<div class="c2">+    }</div>
<div class="c2">+</div>
<div class="c2">+    return false;</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c0"> function createRoom(map, room) {</div>
<div class="c0">     for (let y = room.y1 + 1; y &lt; room.y2; y++) {</div>
<div class="c0">         for (let x = room.x1 + 1; x &lt; room.x2; x++) {</div>
<div class="c3">-            map.setTile(0, x, y, TILE_FLOOR, false);</div>
<div class="c2">+            map[y][x].blocked = false;</div>
<div class="c2">+            map[y][x].blockSight = false;</div>
<div class="c0">         }</div>
<div class="c0">     }</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c0"> function createHTunnel(map, x1, x2, y) {</div>
<div class="c0">     for (let x = Math.min(x1, x2); x &lt;= Math.max(x1, x2); x++) {</div>
<div class="c3">-        map.setTile(0, x, y, TILE_FLOOR, false);</div>
<div class="c2">+        map[y][x].blocked = false;</div>
<div class="c2">+        map[y][x].blockSight = false;</div>
<div class="c0">     }</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c0"> function createVTunnel(map, y1, y2, x) {</div>
<div class="c0">     for (let y = Math.min(y1, y2); y &lt;= Math.max(y1, y2); y++) {</div>
<div class="c3">-        map.setTile(0, x, y, TILE_FLOOR, false);</div>
<div class="c2">+        map[y][x].blocked = false;</div>
<div class="c2">+        map[y][x].blockSight = false;</div>
<div class="c0">     }</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c0"> function createMap() {</div>
<div class="c3">-    // Clear the map to all walls</div>
<div class="c2">+    const map = new Array(MAP_HEIGHT);</div>
<div class="c0">     for (let y = 0; y &lt; MAP_HEIGHT; y++) {</div>
<div class="c2">+        map[y] = new Array(MAP_WIDTH);</div>
<div class="c0">         for (let x = 0; x &lt; MAP_WIDTH; x++) {</div>
<div class="c3">-            map.setTile(0, x, y, TILE_WALL, true);</div>
<div class="c2">+            map[y][x] = new Tile(true);</div>
<div class="c0">         }</div>
<div class="c0">     }</div>
<div class="c0"> </div>
<div class="c3">-    // Reset field-of-view</div>
<div class="c3">-    map.resetFov();</div>
<div class="c3">-</div>
<div class="c0">     const rooms = [];</div>
<div class="c0"> </div>
<div class="c0">     for (let r = 0; r &lt; MAX_ROOMS; r++) {</div>
<div class="c1">@@ -64,11 +284,11 @@</div>
<div class="c0">         const h = rng.nextRange(ROOM_MIN_SIZE, ROOM_MAX_SIZE);</div>
<div class="c0"> </div>
<div class="c0">         // Random position without going out of the boundaries of the map</div>
<div class="c3">-        const x = rng.nextRange(1, MAP_WIDTH - w - 2);</div>
<div class="c3">-        const y = rng.nextRange(1, MAP_HEIGHT - h - 2);</div>
<div class="c2">+        const x = rng.nextRange(0, MAP_WIDTH - w - 1);</div>
<div class="c2">+        const y = rng.nextRange(0, MAP_HEIGHT - h - 1);</div>
<div class="c0"> </div>
<div class="c0">         // &quot;Rect&quot; class makes rectangles easier to work with</div>
<div class="c3">-        const newRoom = new wglt.Rect(x, y, w, h);</div>
<div class="c2">+        const newRoom = new Rect(x, y, w, h);</div>
<div class="c0"> </div>
<div class="c0">         // Run through the other rooms and see if they intersect with this one</div>
<div class="c0">         let failed = false;</div>
<div class="c1">@@ -92,13 +312,6 @@</div>
<div class="c0">                 // This is the first room, where the player starts at</div>
<div class="c0">                 player.x = center.x;</div>
<div class="c0">                 player.y = center.y;</div>
<div class="c3">-</div>
<div class="c3">-                // TEMP: Give the player a fireball</div>
<div class="c3">-                const item = new wglt.Item(game, player.x, player.y + 1, &#x27;fireball&#x27;, new wglt.Sprite(144, 16, 16, 16, 1));</div>
<div class="c3">-                item.onPickup = pickupCallback;</div>
<div class="c3">-                item.onUse = castConfuse;</div>
<div class="c3">-                game.items.push(item);</div>
<div class="c3">-</div>
<div class="c0">             } else {</div>
<div class="c0">                 // All rooms after the first:</div>
<div class="c0">                 // Connect it to the previous room with a tunnel</div>
<div class="c1">@@ -128,14 +341,51 @@</div>
<div class="c0"> </div>
<div class="c0">     // Create stairs at the center of the last room</div>
<div class="c0">     const stairsLoc = rooms[rooms.length - 1].getCenter();</div>
<div class="c3">-    stairs = new wglt.Entity(game, stairsLoc.x, stairsLoc.y, &#x27;stairs&#x27;, new wglt.Sprite(32, 32, 16, 16, 1), true);</div>
<div class="c3">-    game.entities.push(stairs);</div>
<div class="c3">-    // stairs.sendToBack();</div>
<div class="c2">+    stairs = new Entity(stairsLoc.x, stairsLoc.y, &#x27;&lt;&#x27;, &#x27;stairs&#x27;, wglt.Colors.WHITE);</div>
<div class="c2">+    entities.push(stairs);</div>
<div class="c2">+    stairs.sendToBack();</div>
<div class="c2">+</div>
<div class="c2">+    return map;</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function fromDungeonLevel(table) {</div>
<div class="c2">+    // Returns a value that depends on level.</div>
<div class="c2">+    // The table specifies what value occurs after each level, default is 0.</div>
<div class="c2">+    for (let i = 0; i &lt; table.length; i++) {</div>
<div class="c2">+        const value = table[i][0];</div>
<div class="c2">+        const level = table[i][1];</div>
<div class="c2">+        if (dungeonLevel &gt;= level) {</div>
<div class="c2">+            return value;</div>
<div class="c2">+        }</div>
<div class="c2">+    }</div>
<div class="c2">+    return 0;</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c0"> function placeObjects(room) {</div>
<div class="c2">+    // This is where we decide the chance of each monster or item appearing.</div>
<div class="c2">+</div>
<div class="c2">+    // Maximum number of monsters per room</div>
<div class="c2">+    const maxMonsters = fromDungeonLevel([[2, 1], [3, 4], [5, 6]]);</div>
<div class="c2">+</div>
<div class="c2">+    // Chance of each monster</div>
<div class="c2">+    const monsterChances = {</div>
<div class="c2">+        &#x27;orc&#x27;: 80, // orc always shows up, even if all other monsters have 0 chance</div>
<div class="c2">+        &#x27;troll&#x27;: fromDungeonLevel([[15, 3], [30, 5], [60, 7]])</div>
<div class="c2">+    };</div>
<div class="c2">+</div>
<div class="c2">+    // Maximum number of items per room</div>
<div class="c2">+    const maxItems = fromDungeonLevel([[1, 1], [2, 4]])</div>
<div class="c2">+</div>
<div class="c2">+    // Chance of each item (by default they have a chance of 0 at level 1, which then goes up)</div>
<div class="c2">+    const itemChances = {</div>
<div class="c2">+        &#x27;heal&#x27;: 35,  // healing potion always shows up, even if all other items have 0 chance</div>
<div class="c2">+        &#x27;lightning&#x27;: fromDungeonLevel([[25, 4]]),</div>
<div class="c2">+        &#x27;fireball&#x27;: fromDungeonLevel([[25, 6]]),</div>
<div class="c2">+        &#x27;confuse&#x27;: fromDungeonLevel([[10, 2]])</div>
<div class="c2">+    };</div>
<div class="c2">+</div>
<div class="c0">     // Choose random number of monsters</div>
<div class="c3">-    const numMonsters = rng.nextRange(0, MAX_ROOM_MONSTERS);</div>
<div class="c2">+    const numMonsters = rng.nextRange(0, maxMonsters + 1);</div>
<div class="c0"> </div>
<div class="c0">     for (let i = 0; i &lt; numMonsters; i++) {</div>
<div class="c0">         // Choose random spot for this monster</div>
<div class="c1">@@ -143,79 +393,271 @@</div>
<div class="c0">         const y = rng.nextRange(room.y1 + 1, room.y2 - 1);</div>
<div class="c0">         let monster = null;</div>
<div class="c0"> </div>
<div class="c3">-        // Only place it if the tile is not blocked</div>
<div class="c3">-        // 80% chance of getting an orc</div>
<div class="c3">-        if (rng.nextRange(0, 100) &lt; 80) {</div>
<div class="c3">-            // Create an orc</div>
<div class="c3">-            monster = new wglt.Entity(game, x, y, &#x27;Orc&#x27;, new wglt.Sprite(32, 16, 16, 16, 2, true), true);</div>
<div class="c3">-        } else {</div>
<div class="c3">-            // Create a troll</div>
<div class="c3">-            monster = new wglt.Entity(game, x, y, &#x27;Troll&#x27;, new wglt.Sprite(64, 16, 16, 16, 2, true), true);</div>
<div class="c2">+        const choice = rng.chooseKey(monsterChances);</div>
<div class="c2">+        if (choice === &#x27;orc&#x27;) {</div>
<div class="c2">+            const fighter = new Fighter(20, 0, 4, 35, monsterDeath);</div>
<div class="c2">+            const ai = new BasicMonster();</div>
<div class="c2">+            monster = new Entity(x, y, &#x27;o&#x27;, &#x27;orc&#x27;, wglt.Colors.LIGHT_GREEN, true, { fighter: fighter, ai: ai });</div>
<div class="c2">+</div>
<div class="c2">+        } else if (choice === &#x27;troll&#x27;) {</div>
<div class="c2">+            const fighter = new Fighter(30, 2, 8, 100, monsterDeath);</div>
<div class="c2">+            const ai = new BasicMonster();</div>
<div class="c2">+            monster = new Entity(x, y, &#x27;T&#x27;, &#x27;troll&#x27;, wglt.Colors.DARK_GREEN, true, { fighter: fighter, ai: ai });</div>
<div class="c0">         }</div>
<div class="c0"> </div>
<div class="c3">-        monster.health = 20;</div>
<div class="c3">-        monster.canAttack = true;</div>
<div class="c3">-        monster.ai = new wglt.BasicMonster(monster);</div>
<div class="c3">-        monster.onAttack = attackCallback;</div>
<div class="c3">-        monster.onDeath = monsterDeath;</div>
<div class="c3">-        game.entities.push(monster);</div>
<div class="c2">+        entities.push(monster);</div>
<div class="c0">     }</div>
<div class="c0"> </div>
<div class="c0">     // Choose random number of items</div>
<div class="c3">-    const numItems = rng.nextRange(0, MAX_ROOM_ITEMS);</div>
<div class="c2">+    const numItems = rng.nextRange(0, maxItems + 1);</div>
<div class="c0"> </div>
<div class="c0">     for (let i = 0; i &lt; numItems; i++) {</div>
<div class="c0">         // Choose random spot for this item</div>
<div class="c3">-        const x = rng.nextRange(room.x1 + 1, room.x2 - 1);</div>
<div class="c3">-        const y = rng.nextRange(room.y1 + 1, room.y2 - 1);</div>
<div class="c2">+        const x = rng.nextRange(room.x1 + 1, room.x2 - 1)</div>
<div class="c2">+        const y = rng.nextRange(room.y1 + 1, room.y2 - 1)</div>
<div class="c2">+        let item = null;</div>
<div class="c2">+</div>
<div class="c2">+        const choice = rng.chooseKey(itemChances);</div>
<div class="c2">+        if (choice === &#x27;heal&#x27;) {</div>
<div class="c2">+            // Create a healing potion</div>
<div class="c2">+            item = new Entity(x, y, &#x27;!&#x27;, &#x27;healing potion&#x27;, wglt.Colors.DARK_MAGENTA, false, { item: new Item(castHeal) });</div>
<div class="c2">+</div>
<div class="c2">+        } else if (choice === &#x27;lightning&#x27;) {</div>
<div class="c2">+            // Create a lightning bolt scroll</div>
<div class="c2">+            item = new Entity(x, y, &#x27;#&#x27;, &#x27;scroll of lightning bolt&#x27;, wglt.Colors.YELLOW, false, { item: new Item(castLightning) });</div>
<div class="c2">+</div>
<div class="c2">+        } else if (choice === &#x27;fireball&#x27;) {</div>
<div class="c2">+            // Create a fireball scroll</div>
<div class="c2">+            item = new Entity(x, y, &#x27;#&#x27;, &#x27;scroll of fireball&#x27;, wglt.Colors.YELLOW, false, { item: new Item(castFireball) });</div>
<div class="c2">+</div>
<div class="c2">+        } else if (choice === &#x27;confuse&#x27;) {</div>
<div class="c2">+            // Create a confuse scroll</div>
<div class="c2">+            item = new Entity(x, y, &#x27;#&#x27;, &#x27;scroll of confusion&#x27;, wglt.Colors.YELLOW, false, { item: new Item(castConfuse) });</div>
<div class="c2">+        }</div>
<div class="c2">+</div>
<div class="c2">+        entities.push(item);</div>
<div class="c2">+        item.sendToBack();  // items appear below other objects</div>
<div class="c2">+    }</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function renderBar(x, y, totalWidth, name, value, maximum, barColor, backColor) {</div>
<div class="c2">+    // Render a bar (HP, experience, etc). first calculate the width of the bar</div>
<div class="c2">+    const barWidth = Math.round(value / maximum * totalWidth);</div>
<div class="c2">+</div>
<div class="c2">+    // Render the background first</div>
<div class="c2">+    //app.fillRect(x, y, totalWidth, 1, 0, 0, backColor);</div>
<div class="c2">+</div>
<div class="c2">+    // Now render the bar on top</div>
<div class="c2">+    if (barWidth &gt; 0) {</div>
<div class="c2">+        //app.fillRect(x, y, barWidth, 1, 0, 0, barColor);</div>
<div class="c2">+    }</div>
<div class="c2">+</div>
<div class="c2">+    // Finally, some centered text with the values</div>
<div class="c2">+    // app.fillForegroundRect(x, y, totalWidth, 1, wglt.Colors.WHITE);</div>
<div class="c2">+    app.drawCenteredString(x + totalWidth / 2, y, name + &#x27;: &#x27; + value + &#x27;/&#x27; + maximum, wglt.Colors.WHITE);</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function getNamesUnderMouse() {</div>
<div class="c2">+    const x = app.mouse.x;</div>
<div class="c2">+    const y = app.mouse.y;</div>
<div class="c2">+</div>
<div class="c2">+    if (!fovMap.isVisible(x, y)) {</div>
<div class="c2">+        return &#x27;&#x27;;</div>
<div class="c2">+    }</div>
<div class="c2">+</div>
<div class="c2">+    const names = [];</div>
<div class="c2">+</div>
<div class="c2">+    for (let i = 0; i &lt; entities.length; i++) {</div>
<div class="c2">+        const entity = entities[i];</div>
<div class="c2">+        if (entity.x === x &amp;&amp; entity.y === y) {</div>
<div class="c2">+            names.push(entity.name);</div>
<div class="c2">+        }</div>
<div class="c2">+    }</div>
<div class="c2">+</div>
<div class="c2">+    return capitalize(names.join(&#x27;, &#x27;));</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function addMessage(msg, opt_color) {</div>
<div class="c2">+    while (messages.length &gt;= MSG_HEIGHT) {</div>
<div class="c2">+        messages.shift();</div>
<div class="c2">+    }</div>
<div class="c2">+    messages.push({ text: msg, color: (opt_color || wglt.Colors.WHITE) });</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function capitalize(str) {</div>
<div class="c2">+    if (!str) {</div>
<div class="c2">+        return str;</div>
<div class="c2">+    }</div>
<div class="c2">+    return str.charAt(0).toUpperCase() + str.slice(1);</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function playerMoveOrAttack(dx, dy) {</div>
<div class="c2">+    const x = player.x + dx;</div>
<div class="c2">+    const y = player.y + dy;</div>
<div class="c2">+</div>
<div class="c2">+    let target = null;</div>
<div class="c2">+    for (let i = 0; i &lt; entities.length; i++) {</div>
<div class="c2">+        const entity = entities[i];</div>
<div class="c2">+        if (entity.fighter &amp;&amp; entity.x === x &amp;&amp; entity.y === y) {</div>
<div class="c2">+            target = entity;</div>
<div class="c2">+            break;</div>
<div class="c2">+        }</div>
<div class="c2">+    }</div>
<div class="c2">+</div>
<div class="c2">+    if (target) {</div>
<div class="c2">+        player.fighter.attack(target);</div>
<div class="c2">+    } else {</div>
<div class="c2">+        player.move(dx, dy);</div>
<div class="c2">+        fovRecompute = true;</div>
<div class="c2">+    }</div>
<div class="c2">+</div>
<div class="c2">+    for (let i = 0; i &lt; entities.length; i++) {</div>
<div class="c2">+        const entity = entities[i];</div>
<div class="c2">+        if (entity.ai) {</div>
<div class="c2">+            entity.ai.takeTurn();</div>
<div class="c2">+        }</div>
<div class="c2">+    }</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function handleKeys() {</div>
<div class="c2">+    if (player.fighter.hp &lt;= 0) {</div>
<div class="c2">+        return;</div>
<div class="c2">+    }</div>
<div class="c2">+</div>
<div class="c2">+    if (gui.handleInput()) {</div>
<div class="c2">+        return;</div>
<div class="c2">+    }</div>
<div class="c0"> </div>
<div class="c3">-        const dice = rng.nextRange(0, 100);</div>
<div class="c3">-        let itemName = null;</div>
<div class="c3">-        let itemSprite = null;</div>
<div class="c3">-        let itemUse = null;</div>
<div class="c3">-</div>
<div class="c3">-        if (dice &lt; 50) {</div>
<div class="c3">-            // Create a healing potion (50% chance)</div>
<div class="c3">-            itemName = &#x27;healing potion&#x27;;</div>
<div class="c3">-            itemSprite = new wglt.Sprite(128, 16, 16, 16, 1);</div>
<div class="c3">-            itemUse = castHeal;</div>
<div class="c3">-</div>
<div class="c3">-        } else if (dice &lt; 50 + 20) {</div>
<div class="c3">-            // Create a lightning bolt scroll (20% chance)</div>
<div class="c3">-            itemName = &#x27;scroll of lightning bolt&#x27;;</div>
<div class="c3">-            itemSprite = new wglt.Sprite(144, 16, 16, 16, 1);</div>
<div class="c3">-            itemUse = castLightning;</div>
<div class="c3">-</div>
<div class="c3">-        } else if (dice &lt; 50 + 20 + 15) {</div>
<div class="c3">-            // Create a fireball scroll (15% chance)</div>
<div class="c3">-            itemName = &#x27;scroll of fireball&#x27;;</div>
<div class="c3">-            itemSprite = new wglt.Sprite(144, 16, 16, 16, 1);</div>
<div class="c3">-            itemUse = castFireball;</div>
<div class="c2">+    if (targetFunction) {</div>
<div class="c2">+        if (app.isKeyPressed(wglt.Keys.VK_ENTER) || app.mouse.buttons[0]) {</div>
<div class="c2">+            endTargeting(targetCursor.x, targetCursor.y);</div>
<div class="c2">+        }</div>
<div class="c2">+        if (app.isKeyPressed(wglt.Keys.VK_ESCAPE) || app.mouse.buttons[2]) {</div>
<div class="c2">+            cancelTargeting();</div>
<div class="c2">+        }</div>
<div class="c2">+        if (app.isKeyPressed(wglt.Keys.VK_UP)) {</div>
<div class="c2">+            targetCursor.y--;</div>
<div class="c2">+        }</div>
<div class="c2">+        if (app.isKeyPressed(wglt.Keys.VK_LEFT)) {</div>
<div class="c2">+            targetCursor.x--;</div>
<div class="c2">+        }</div>
<div class="c2">+        if (app.isKeyPressed(wglt.Keys.VK_RIGHT)) {</div>
<div class="c2">+            targetCursor.x++;</div>
<div class="c2">+        }</div>
<div class="c2">+        if (app.isKeyPressed(wglt.Keys.VK_DOWN)) {</div>
<div class="c2">+            targetCursor.y++;</div>
<div class="c2">+        }</div>
<div class="c2">+        if (app.mouse.dx !== 0 || app.mouse.dy !== 0) {</div>
<div class="c2">+            targetCursor.x = app.mouse.x;</div>
<div class="c2">+            targetCursor.y = app.mouse.y;</div>
<div class="c2">+        }</div>
<div class="c2">+        return;</div>
<div class="c2">+    }</div>
<div class="c0"> </div>
<div class="c2">+    if (app.isKeyPressed(wglt.Keys.VK_ESCAPE)) {</div>
<div class="c2">+        saveGame();</div>
<div class="c2">+        appState = &#x27;menu&#x27;;</div>
<div class="c2">+    }</div>
<div class="c2">+    if (app.isKeyPressed(wglt.Keys.VK_UP)) {</div>
<div class="c2">+        playerMoveOrAttack(0, -1);</div>
<div class="c2">+    }</div>
<div class="c2">+    if (app.isKeyPressed(wglt.Keys.VK_LEFT)) {</div>
<div class="c2">+        playerMoveOrAttack(-1, 0);</div>
<div class="c2">+    }</div>
<div class="c2">+    if (app.isKeyPressed(wglt.Keys.VK_RIGHT)) {</div>
<div class="c2">+        playerMoveOrAttack(1, 0);</div>
<div class="c2">+    }</div>
<div class="c2">+    if (app.isKeyPressed(wglt.Keys.VK_DOWN)) {</div>
<div class="c2">+        playerMoveOrAttack(0, 1);</div>
<div class="c2">+    }</div>
<div class="c2">+    if (app.isKeyPressed(wglt.Keys.VK_G)) {</div>
<div class="c2">+        // Pick up an item</div>
<div class="c2">+        for (let i = 0; i &lt; entities.length; i++) {</div>
<div class="c2">+            const entity = entities[i];</div>
<div class="c2">+            if (entity.x === player.x &amp;&amp; entity.y === player.y &amp;&amp; entity.item) {</div>
<div class="c2">+                entity.item.pickUp();</div>
<div class="c2">+            }</div>
<div class="c2">+        }</div>
<div class="c2">+    }</div>
<div class="c2">+    if (app.isKeyPressed(wglt.Keys.VK_I)) {</div>
<div class="c2">+        if (inventory.length === 0) {</div>
<div class="c2">+            gui.add(new wglt.MessageDialog(&#x27;ALERT&#x27;, &#x27;Inventory is empty&#x27;));</div>
<div class="c0">         } else {</div>
<div class="c3">-            // Create a confuse scroll (15% chance)</div>
<div class="c3">-            itemName = &#x27;scroll of confusion&#x27;;</div>
<div class="c3">-            itemSprite = new wglt.Sprite(144, 16, 16, 16, 1);</div>
<div class="c3">-            itemUse = castConfuse;</div>
<div class="c2">+            const options = inventory.map(item =&gt; item.name);</div>
<div class="c2">+            gui.add(new wglt.SelectDialog(&#x27;INVENTORY&#x27;, options, useInventory));</div>
<div class="c2">+        }</div>
<div class="c2">+    }</div>
<div class="c2">+    if (app.isKeyPressed(wglt.Keys.VK_C)) {</div>
<div class="c2">+        const levelUpXp = LEVEL_UP_BASE + player.level * LEVEL_UP_FACTOR;</div>
<div class="c2">+        gui.add(new wglt.MessageDialog(&#x27;CHARACTER&#x27;,</div>
<div class="c2">+            &#x27;Level: &#x27; + player.level +</div>
<div class="c2">+            &#x27;\nExperience: &#x27; + player.fighter.xp +</div>
<div class="c2">+            &#x27;\nExperience to level up: &#x27; + levelUpXp +</div>
<div class="c2">+            &#x27;\n\nMaximum HP: &#x27; + player.fighter.maxHp +</div>
<div class="c2">+            &#x27;\nAttack: &#x27; + player.fighter.power +</div>
<div class="c2">+            &#x27;\nDefense: &#x27; + player.fighter.defense));</div>
<div class="c2">+    }</div>
<div class="c2">+    if (app.isKeyPressed(wglt.Keys.VK_COMMA)) {</div>
<div class="c2">+        if (player.x === stairs.x &amp;&amp; player.y === stairs.y) {</div>
<div class="c2">+            nextLevel();</div>
<div class="c0">         }</div>
<div class="c2">+    }</div>
<div class="c2">+}</div>
<div class="c0"> </div>
<div class="c3">-        const item = new wglt.Item(game, x, y, itemName, itemSprite);</div>
<div class="c3">-        item.onPickup = pickupCallback;</div>
<div class="c3">-        item.onUse = itemUse;</div>
<div class="c3">-        game.items.push(item);</div>
<div class="c2">+function useInventory(choice) {</div>
<div class="c2">+    if (choice &gt;= 0) {</div>
<div class="c2">+        inventory[choice].item.use();</div>
<div class="c2">+    }</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function checkLevelUp() {</div>
<div class="c2">+    // See if the player&#x27;s experience is enough to level-up</div>
<div class="c2">+    const levelUpXp = LEVEL_UP_BASE + player.level * LEVEL_UP_FACTOR;</div>
<div class="c2">+    if (player.fighter.xp &gt;= levelUpXp) {</div>
<div class="c2">+        player.level++;</div>
<div class="c2">+        player.fighter.xp -= levelUpXp;</div>
<div class="c2">+        addMessage(&#x27;Your battle skills grow stronger! You reached level &#x27; + player.level + &#x27;!&#x27;, wglt.Colors.YELLOW);</div>
<div class="c2">+</div>
<div class="c2">+        const options = [</div>
<div class="c2">+            &#x27;Constitution (+20 HP, from &#x27; + player.fighter.maxHp + &#x27;)&#x27;,</div>
<div class="c2">+            &#x27;Strength (+1 attack, from &#x27; + player.fighter.power + &#x27;)&#x27;,</div>
<div class="c2">+            &#x27;Agility (+1 defense, from &#x27; + player.fighter.defense + &#x27;)&#x27;</div>
<div class="c2">+        ];</div>
<div class="c2">+</div>
<div class="c2">+        gui.add(new wglt.SelectDialog(&#x27;LEVEL UP&#x27;, options, (choice) =&gt; {</div>
<div class="c2">+            if (choice === 0) {</div>
<div class="c2">+                player.fighter.maxHp += 20;</div>
<div class="c2">+                player.fighter.hp += 20;</div>
<div class="c2">+            } else if (choice === 1) {</div>
<div class="c2">+                player.fighter.power += 1;</div>
<div class="c2">+            } else if (choice === 2) {</div>
<div class="c2">+                player.fighter.defense += 1;</div>
<div class="c2">+            }</div>
<div class="c2">+        }));</div>
<div class="c0">     }</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c3">-function pickupCallback(entity, item) {</div>
<div class="c3">-    messageLog.add(entity.name + &#x27; picked up a &#x27; + item.name, wglt.Colors.LIGHT_GREEN);</div>
<div class="c2">+function playerDeath(player) {</div>
<div class="c2">+    addMessage(&#x27;You died!&#x27;, wglt.Colors.LIGHT_RED);</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function monsterDeath(monster) {</div>
<div class="c2">+    addMessage(capitalize(monster.name) + &#x27; is dead! You gain &#x27; + monster.fighter.xp + &#x27; XP.&#x27;, wglt.Colors.ORANGE);</div>
<div class="c2">+    monster.char = &#x27;%&#x27;;</div>
<div class="c2">+    monster.color = wglt.Colors.DARK_RED;</div>
<div class="c2">+    monster.blocks = false;</div>
<div class="c2">+    monster.fighter = null;</div>
<div class="c2">+    monster.ai = null;</div>
<div class="c2">+    monster.name = &#x27;remains of &#x27; + monster.name;</div>
<div class="c2">+    monster.sendToBack();</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c0"> function getClosestMonster(x, y, range) {</div>
<div class="c0">     let minDist = range + 1;</div>
<div class="c0">     let result = null;</div>
<div class="c3">-    for (let i = 0; i &lt; game.entities.length; i++) {</div>
<div class="c3">-        const entity = game.entities[i];</div>
<div class="c3">-        if (entity !== player) {</div>
<div class="c2">+    for (let i = 0; i &lt; entities.length; i++) {</div>
<div class="c2">+        const entity = entities[i];</div>
<div class="c2">+        if (entity.fighter &amp;&amp; entity !== player) {</div>
<div class="c0">             const dist = entity.distance(x, y);</div>
<div class="c0">             if (dist &lt; minDist) {</div>
<div class="c0">                 minDist = dist;</div>
<div class="c1">@@ -230,15 +672,15 @@</div>
<div class="c0">     return getClosestMonster(x, y, 0);</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c3">-function castHeal(item, entity) {</div>
<div class="c2">+function castHeal(item) {</div>
<div class="c0">     // Heal the player</div>
<div class="c3">-    if (player.health === player.maxHealth) {</div>
<div class="c3">-        messageLog.add(&#x27;You are already at full health.&#x27;, wglt.Colors.DARK_RED);</div>
<div class="c2">+    if (player.fighter.hp === player.fighter.maxHp) {</div>
<div class="c2">+        addMessage(&#x27;You are already at full health.&#x27;, wglt.Colors.DARK_RED);</div>
<div class="c0">         return;</div>
<div class="c0">     }</div>
<div class="c0"> </div>
<div class="c3">-    messageLog.add(&#x27;Your wounds start to feel better!&#x27;, wglt.Colors.LIGHT_MAGENTA);</div>
<div class="c3">-    player.health += HEAL_AMOUNT;</div>
<div class="c2">+    addMessage(&#x27;Your wounds start to feel better!&#x27;, wglt.Colors.LIGHT_MAGENTA);</div>
<div class="c2">+    player.fighter.heal(HEAL_AMOUNT);</div>
<div class="c0">     item.remove();</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c1">@@ -246,235 +688,240 @@</div>
<div class="c0">     // Find closest enemy (inside a maximum range) and damage it</div>
<div class="c0">     const monster = getClosestMonster(player.x, player.y, LIGHTNING_RANGE);</div>
<div class="c0">     if (!monster) {</div>
<div class="c3">-        messageLog.add(&#x27;No enemy is close enough to strike.&#x27;, wglt.Colors.LIGHT_RED);</div>
<div class="c2">+        addMessage(&#x27;No enemy is close enough to strike.&#x27;, wglt.Colors.LIGHT_RED);</div>
<div class="c0">         return;</div>
<div class="c0">     }</div>
<div class="c0"> </div>
<div class="c0">     // Zap it!</div>
<div class="c3">-    messageLog.add(&#x27;A lightning bolt strikes the &#x27; + monster.name + &#x27; with a loud thunder!&#x27;, wglt.Colors.LIGHT_BLUE);</div>
<div class="c3">-    messageLog.add(&#x27;The damage is &#x27; + LIGHTNING_DAMAGE + &#x27; hit points&#x27;, wglt.Colors.LIGHT_BLUE);</div>
<div class="c3">-    monster.takeDamage(LIGHTNING_DAMAGE);</div>
<div class="c2">+    addMessage(&#x27;A lightning bolt strikes the &#x27; + monster.name + &#x27; with a loud thunder!&#x27;, wglt.Colors.LIGHT_BLUE);</div>
<div class="c2">+    addMessage(&#x27;The damage is &#x27; + LIGHTNING_DAMAGE + &#x27; hit points&#x27;, wglt.Colors.LIGHT_BLUE);</div>
<div class="c2">+    monster.fighter.takeDamage(LIGHTNING_DAMAGE);</div>
<div class="c0">     item.remove();</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c0"> function castFireball(item) {</div>
<div class="c0">     // Ask the player for a target tile to throw a fireball at</div>
<div class="c3">-    messageLog.add(&#x27;Left-click to cast fireball, or right-click to cancel.&#x27;, wglt.Colors.LIGHT_CYAN);</div>
<div class="c3">-    game.startTargeting((x, y) =&gt; {</div>
<div class="c3">-        const distance = player.distance(x, y);</div>
<div class="c3">-        if (distance &gt; FIREBALL_RANGE) {</div>
<div class="c3">-            messageLog.add(&#x27;Target out of range.&#x27;, wglt.Colors.LIGHT_GRAY);</div>
<div class="c2">+    addMessage(&#x27;Left-click to cast fireball, or right-click to cancel.&#x27;, wglt.Colors.LIGHT_CYAN);</div>
<div class="c2">+    startTargeting((x, y) =&gt; {</div>
<div class="c2">+        if (player.distance(x, y) &gt; FIREBALL_RANGE) {</div>
<div class="c2">+            addMessage(&#x27;Target out of range.&#x27;, wglt.Colors.LIGHT_GRAY);</div>
<div class="c0">             return;</div>
<div class="c0">         }</div>
<div class="c0"> </div>
<div class="c3">-        const speed = 8;</div>
<div class="c3">-        const count = distance * (game.tileWidth / speed);</div>
<div class="c3">-        const dx = (x * game.tileWidth - player.pixelX) / count;</div>
<div class="c3">-        const dy = (y * game.tileHeight - player.pixelY) / count;</div>
<div class="c3">-</div>
<div class="c3">-        game.effects.push(new wglt.ProjectileEffect(</div>
<div class="c3">-            new wglt.Sprite(128, 32, 16, 16, 3, false),</div>
<div class="c3">-            new wglt.MutablePoint(player.pixelX, player.pixelY),</div>
<div class="c3">-            new wglt.Point(dx, dy),</div>
<div class="c3">-            count</div>
<div class="c3">-        ));</div>
<div class="c3">-</div>
<div class="c3">-        game.effects.push(new wglt.ProjectileEffect(</div>
<div class="c3">-            new wglt.Sprite(176, 32, 16, 16, 4, false, 4),</div>
<div class="c3">-            new wglt.MutablePoint(x * game.tileWidth, y * game.tileHeight),</div>
<div class="c3">-            new wglt.Point(0, 0),</div>
<div class="c3">-            16</div>
<div class="c3">-        ));</div>
<div class="c3">-</div>
<div class="c3">-        messageLog.add(&#x27;The fireball explodes, burning everything within &#x27; + FIREBALL_RADIUS + &#x27; tiles!&#x27;, wglt.Colors.ORANGE);</div>
<div class="c3">-</div>
<div class="c3">-        for (let i = game.entities.length - 1; i &gt;= 0; i--) {</div>
<div class="c3">-            const entity = game.entities[i];</div>
<div class="c3">-            if (entity.distance(x, y) &lt;= FIREBALL_RADIUS) {</div>
<div class="c3">-                messageLog.add(&#x27;The &#x27; + entity.name + &#x27; gets burned for &#x27; + FIREBALL_DAMAGE + &#x27; hit points.&#x27;, wglt.Colors.ORANGE);</div>
<div class="c3">-                entity.takeDamage(FIREBALL_DAMAGE);</div>
<div class="c2">+        addMessage(&#x27;The fireball explodes, burning everything within &#x27; + FIREBALL_RADIUS + &#x27; tiles!&#x27;, wglt.Colors.ORANGE);</div>
<div class="c2">+</div>
<div class="c2">+        for (let i = 0; i &lt; entities.length; i++) {</div>
<div class="c2">+            const entity = entities[i];</div>
<div class="c2">+            if (entity.fighter &amp;&amp; entity.distance(x, y) &lt;= FIREBALL_RADIUS) {</div>
<div class="c2">+                addMessage(&#x27;The &#x27; + entity.name + &#x27; gets burned for &#x27; + FIREBALL_DAMAGE + &#x27; hit points.&#x27;, wglt.Colors.ORANGE);</div>
<div class="c2">+                entity.fighter.takeDamage(FIREBALL_DAMAGE);</div>
<div class="c0">             }</div>
<div class="c0">         }</div>
<div class="c0"> </div>
<div class="c3">-        player.actionPoints = 0;</div>
<div class="c3">-        //item.remove();</div>
<div class="c2">+        item.remove();</div>
<div class="c0">     });</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c0"> function castConfuse(item) {</div>
<div class="c0">     // Ask the player for a target to confuse</div>
<div class="c3">-    messageLog.add(&#x27;Left-click to cast confuse, or right-click to cancel.&#x27;, wglt.Colors.LIGHT_CYAN);</div>
<div class="c3">-    game.startTargeting((x, y) =&gt; {</div>
<div class="c2">+    addMessage(&#x27;Left-click to cast confuse, or right-click to cancel.&#x27;, wglt.Colors.LIGHT_CYAN);</div>
<div class="c2">+    startTargeting((x, y) =&gt; {</div>
<div class="c0">         if (player.distance(x, y) &gt; CONFUSE_RANGE) {</div>
<div class="c3">-            messageLog.add(&#x27;Target out of range.&#x27;, wglt.Colors.LIGHT_GRAY);</div>
<div class="c2">+            addMessage(&#x27;Target out of range.&#x27;, wglt.Colors.LIGHT_GRAY);</div>
<div class="c0">             return;</div>
<div class="c0">         }</div>
<div class="c0"> </div>
<div class="c0">         const monster = getMonsterAt(x, y);</div>
<div class="c0">         if (!monster) {</div>
<div class="c3">-            messageLog.add(&#x27;No monster there.&#x27;, wglt.Colors.LIGHT_GRAY);</div>
<div class="c2">+            addMessage(&#x27;No monster there.&#x27;, wglt.Colors.LIGHT_GRAY);</div>
<div class="c0">             return;</div>
<div class="c0">         }</div>
<div class="c0"> </div>
<div class="c3">-        monster.ai = new wglt.ConfusedMonster(monster);</div>
<div class="c3">-        // monster.ai.owner = monster;</div>
<div class="c3">-        messageLog.add(&#x27;The eyes of the &#x27; + monster.name + &#x27; look vacant, as he stumbles around!&#x27;, wglt.Colors.LIGHT_GREEN);</div>
<div class="c2">+        monster.ai = new ConfusedMonster(monster.ai);</div>
<div class="c2">+        monster.ai.owner = monster;</div>
<div class="c2">+        addMessage(&#x27;The eyes of the &#x27; + monster.name + &#x27; look vacant, as he stumbles around!&#x27;, wglt.Colors.LIGHT_GREEN);</div>
<div class="c0">         item.remove();</div>
<div class="c0">     });</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c3">-function attackCallback(attacker, target, damage) {</div>
<div class="c3">-    if (damage &gt; 0) {</div>
<div class="c3">-        messageLog.add(attacker.name + &#x27; attacks &#x27; + target.name + &#x27; for &#x27; + damage + &#x27; hit points.&#x27;, 0x808080FF);</div>
<div class="c3">-    } else {</div>
<div class="c3">-        messageLog.add(attacker.name + &#x27; attacks &#x27; + target.name + &#x27; but it has no effect!&#x27;, 0x808080FF);</div>
<div class="c3">-    }</div>
<div class="c2">+function startTargeting(callback) {</div>
<div class="c2">+    targetFunction = callback;</div>
<div class="c2">+    targetCursor.x = player.x;</div>
<div class="c2">+    targetCursor.y = player.y;</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c3">-function playerDeath(player) {</div>
<div class="c3">-    messageLog.add(&#x27;You died!&#x27;);</div>
<div class="c2">+function endTargeting(x, y) {</div>
<div class="c2">+    targetFunction(x, y);</div>
<div class="c2">+    cancelTargeting();</div>
<div class="c0"> }</div>
<div class="c0"> </div>
<div class="c3">-function monsterDeath(monster) {</div>
<div class="c3">-    messageLog.add(monster.name + &#x27; is dead&#x27;);</div>
<div class="c3">-    monster.char = &#x27;%&#x27;;</div>
<div class="c3">-    monster.color = wglt.Colors.DARK_RED;</div>
<div class="c3">-    monster.blocks = false;</div>
<div class="c3">-    monster.ai = null;</div>
<div class="c3">-    monster.name = &#x27;remains of &#x27; + monster.name;</div>
<div class="c3">-    monster.sendToBack();</div>
<div class="c2">+function cancelTargeting() {</div>
<div class="c2">+    targetFunction = null;</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function renderAll() {</div>
<div class="c2">+    if (fovRecompute) {</div>
<div class="c2">+        fovMap.computeFov(player.x, player.y, TORCH_RADIUS);</div>
<div class="c2">+        fovRecompute = false;</div>
<div class="c2">+    }</div>
<div class="c0"> </div>
<div class="c3">-    const xpGain = 10;</div>
<div class="c3">-    player.xp += xpGain;</div>
<div class="c2">+    //app.clear();</div>
<div class="c0"> </div>
<div class="c3">-    while (player.xp &gt;= player.maxXp) {</div>
<div class="c3">-        player.level++;</div>
<div class="c3">-        player.xp = 0;</div>
<div class="c3">-        player.maxXp *= 2;</div>
<div class="c3">-        messageLog.add(&#x27;You reached level &#x27; + player.level, 0xFF8000FF);</div>
<div class="c2">+    for (let y = 0; y &lt; MAP_HEIGHT; y++) {</div>
<div class="c2">+        for (let x = 0; x &lt; MAP_WIDTH; x++) {</div>
<div class="c2">+            const visible = fovMap.isVisible(x, y);</div>
<div class="c2">+            const wall = map[y][x].blockSight;</div>
<div class="c2">+            let color = wglt.Colors.BLACK;</div>
<div class="c2">+</div>
<div class="c2">+            if (visible) {</div>
<div class="c2">+                // It&#x27;s visible</div>
<div class="c2">+                color = wall ? COLOR_LIGHT_WALL : COLOR_LIGHT_GROUND;</div>
<div class="c2">+                map[y][x].explored = true;</div>
<div class="c2">+            } else if (map[y][x].explored) {</div>
<div class="c2">+                // It&#x27;s remembered</div>
<div class="c2">+                color = wall ? COLOR_DARK_WALL : COLOR_DARK_GROUND;</div>
<div class="c2">+            }</div>
<div class="c2">+</div>
<div class="c2">+            app.drawChar(x, y, 0, 0, color);</div>
<div class="c2">+        }</div>
<div class="c0">     }</div>
<div class="c3">-}</div>
<div class="c0"> </div>
<div class="c3">-function nextLevel() {</div>
<div class="c3">-    // Advance to the next level</div>
<div class="c3">-    messageLog.add(&#x27;You take a moment to rest, and recover your strength.&#x27;, wglt.Colors.LIGHT_MAGENTA);</div>
<div class="c3">-    // player.fighter.heal(player.fighter.maxHp / 2); // heal the player by 50%</div>
<div class="c3">-    // dungeonLevel++;</div>
<div class="c3">-    messageLog.add(&#x27;After a rare moment of peace, you descend deeper...&#x27;, wglt.Colors.LIGHT_RED);</div>
<div class="c3">-    game.entities = [player];</div>
<div class="c3">-    // map = createMap(); // Create a fresh new level!</div>
<div class="c3">-    createMap();</div>
<div class="c3">-    // fovMap = new wglt.FovMap(MAP_WIDTH, MAP_HEIGHT, (x, y) =&gt; map[y][x].blocked);</div>
<div class="c3">-    // fovRecompute = true;</div>
<div class="c3">-</div>
<div class="c3">-    // Initial FOV</div>
<div class="c3">-    game.tileMap.computeFov(player.x, player.y, 12);</div>
<div class="c3">-}</div>
<div class="c3">-</div>
<div class="c3">-const app = new wglt.App({</div>
<div class="c3">-    canvas: document.querySelector(&#x27;canvas&#x27;),</div>
<div class="c3">-    imageUrl: &#x27;../graphics.png&#x27;,</div>
<div class="c3">-    width: 400,</div>
<div class="c3">-    height: 224,</div>
<div class="c3">-});</div>
<div class="c3">-</div>
<div class="c3">-const game = new wglt.Game(app, {</div>
<div class="c3">-    tileWidth: 16,</div>
<div class="c3">-    tileHeight: 16</div>
<div class="c3">-});</div>
<div class="c3">-</div>
<div class="c3">-game.targetSprite = new wglt.Sprite(0, 48, 16, 16);</div>
<div class="c3">-game.gui.renderer.baseRect = new wglt.Rect(0, 64, 24, 24);</div>
<div class="c3">-</div>
<div class="c3">-const rng = new wglt.RNG(1);</div>
<div class="c3">-const sprite = new wglt.Sprite(0, 16, 16, 16, 2, true);</div>
<div class="c3">-const player = new wglt.Entity(game, 30, 20, &#x27;Player&#x27;, sprite, true);</div>
<div class="c3">-player.onAttack = attackCallback;</div>
<div class="c3">-player.onDeath = playerDeath;</div>
<div class="c3">-player.level = 1;</div>
<div class="c3">-player.xp = 0;</div>
<div class="c3">-player.maxXp = 10;</div>
<div class="c3">-player.onBump = function (other) {</div>
<div class="c3">-    // if (other.canPickup) {</div>
<div class="c3">-</div>
<div class="c3">-    // }</div>
<div class="c3">-    if (other.canAttack) {</div>
<div class="c3">-        player.attack(other);</div>
<div class="c3">-        return true;</div>
<div class="c2">+    for (let i = 0; i &lt; entities.length; i++) {</div>
<div class="c2">+        entities[i].draw();</div>
<div class="c0">     }</div>
<div class="c3">-    if (other.name === &#x27;stairs&#x27;) {</div>
<div class="c3">-        //console.log(&#x27;up da stairs&#x27;);</div>
<div class="c3">-        nextLevel();</div>
<div class="c3">-        return true;</div>
<div class="c2">+</div>
<div class="c2">+    // Prepare to render the GUI panel</div>
<div class="c2">+    //app.fillRect(0, PANEL_Y, SCREEN_WIDTH, PANEL_HEIGHT, 0, wglt.Colors.WHITE, wglt.Colors.BLACK);</div>
<div class="c2">+</div>
<div class="c2">+    // Print the game messages, one line at a time</div>
<div class="c2">+    y = PANEL_Y + 1;</div>
<div class="c2">+    for (let i = 0; i &lt; messages.length; i++) {</div>
<div class="c2">+        const message = messages[i];</div>
<div class="c2">+        app.drawString(MSG_X, y, message.text, message.color);</div>
<div class="c2">+        y++;</div>
<div class="c0">     }</div>
<div class="c3">-};</div>
<div class="c0"> </div>
<div class="c3">-const map = new wglt.TileMap(app.gl, MAP_WIDTH, MAP_HEIGHT, 1);</div>
<div class="c3">-game.tileMap = map;</div>
<div class="c3">-game.player = player;</div>
<div class="c3">-game.entities.push(player);</div>
<div class="c3">-</div>
<div class="c3">-const messageLog = new wglt.MessageLog(game.gui, new wglt.Rect(1, 224 - 50, 100, 100));</div>
<div class="c3">-messageLog.add(&#x27;Welcome stranger! Prepare to perish!&#x27;, wglt.Colors.DARK_RED);</div>
<div class="c3">-game.gui.add(messageLog);</div>
<div class="c3">-</div>
<div class="c3">-const playerStats = new wglt.Panel(game.gui, new wglt.Rect(1, 1, 100, 100));</div>
<div class="c3">-playerStats.drawContents = function () {</div>
<div class="c3">-    const frameY = 0;</div>
<div class="c3">-    app.drawString(player.name, 1, frameY);</div>
<div class="c3">-</div>
<div class="c3">-    const hpPercent = player.health / player.maxHealth;</div>
<div class="c3">-    app.drawImage(0, frameY + 7, 32, 64, 32, 12);</div>
<div class="c3">-    app.drawImage(2, frameY + 9, 32, 80, 8, 8, undefined, Math.round(hpPercent * 28));</div>
<div class="c3">-    app.drawString(player.health + &#x27;/&#x27; + player.maxHealth, 3, frameY + 10);</div>
<div class="c3">-</div>
<div class="c3">-    const xpPercent = player.xp / player.maxXp;</div>
<div class="c3">-    app.drawImage(32, frameY + 7, 32, 64, 32, 12);</div>
<div class="c3">-    app.drawImage(34, frameY + 9, 32, 80, 8, 8, undefined, Math.round(xpPercent * 28));</div>
<div class="c3">-    app.drawString(player.xp + &#x27;/&#x27; + player.maxXp, 35, frameY + 10);</div>
<div class="c3">-};</div>
<div class="c3">-game.gui.add(playerStats);</div>
<div class="c2">+    // Show the player&#x27;s stats</div>
<div class="c2">+    renderBar(</div>
<div class="c2">+        1, PANEL_Y + 1, BAR_WIDTH,</div>
<div class="c2">+        &#x27;HP&#x27;, player.fighter.hp, player.fighter.maxHp,</div>
<div class="c2">+        wglt.Colors.LIGHT_RED, wglt.Colors.DARK_RED);</div>
<div class="c0"> </div>
<div class="c3">-game.onUpdate = function () {</div>
<div class="c3">-    if (app.isKeyPressed(wglt.Keys.VK_I)) {</div>
<div class="c3">-        // Show inventory</div>
<div class="c3">-        game.gui.add(new wglt.SelectDialog(</div>
<div class="c3">-            game.gui,</div>
<div class="c3">-            new wglt.Rect(40, 40, 100, 100),</div>
<div class="c3">-            &#x27;INVENTORY&#x27;,</div>
<div class="c3">-            player.inventory,</div>
<div class="c3">-            (choice) =&gt; {</div>
<div class="c3">-                choice.use(player);</div>
<div class="c3">-            }));</div>
<div class="c2">+    renderBar(</div>
<div class="c2">+        1, PANEL_Y + 2, BAR_WIDTH,</div>
<div class="c2">+        &#x27;XP&#x27;, player.fighter.xp, LEVEL_UP_BASE + player.level * LEVEL_UP_FACTOR,</div>
<div class="c2">+        wglt.Colors.LIGHT_MAGENTA, wglt.Colors.DARK_MAGENTA);</div>
<div class="c2">+</div>
<div class="c2">+    app.drawString(1, PANEL_Y + 4, &#x27;Dungeon level &#x27; + dungeonLevel, wglt.Colors.ORANGE);</div>
<div class="c2">+</div>
<div class="c2">+    // Display names of objects under the mouse</div>
<div class="c2">+    app.drawString(1, PANEL_Y, getNamesUnderMouse(), wglt.Colors.LIGHT_GRAY);</div>
<div class="c2">+</div>
<div class="c2">+    if (targetFunction) {</div>
<div class="c2">+        app.getCell(targetCursor.x, targetCursor.y).setBackground(wglt.Colors.WHITE);</div>
<div class="c0">     }</div>
<div class="c3">-};</div>
<div class="c0"> </div>
<div class="c3">-// Generate the map</div>
<div class="c3">-createMap();</div>
<div class="c2">+    // Draw dialog boxes</div>
<div class="c2">+    gui.draw();</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function saveGame() {</div>
<div class="c2">+    // TODO: JSON.stringify does not support prototypes and circular references</div>
<div class="c2">+    // Investigate Cryo: https://github.com/hunterloftis/cryo</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function loadGame() {</div>
<div class="c2">+    // TODO</div>
<div class="c2">+    if (!player) {</div>
<div class="c2">+        return;</div>
<div class="c2">+    }</div>
<div class="c2">+    appState = &#x27;game&#x27;;</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function newGame() {</div>
<div class="c2">+    rng = new wglt.RNG(Date.now());</div>
<div class="c2">+    player = new Entity(40, 25, &#x27;@&#x27;, &#x27;player&#x27;, wglt.Colors.WHITE, true, { fighter: new Fighter(100, 1, 4, 0, playerDeath) });</div>
<div class="c2">+    player.level = 1;</div>
<div class="c2">+    entities = [player];</div>
<div class="c2">+    messages = [];</div>
<div class="c2">+    dungeonLevel = 1;</div>
<div class="c2">+    map = createMap();</div>
<div class="c2">+    fovMap = new wglt.FovMap(MAP_WIDTH, MAP_HEIGHT, (x, y) =&gt; map[y][x].blocked);</div>
<div class="c2">+    fovRecompute = true;</div>
<div class="c2">+    inventory = [];</div>
<div class="c2">+    addMessage(&#x27;Welcome stranger! Prepare to perish!&#x27;, wglt.Colors.DARK_RED);</div>
<div class="c2">+    appState = &#x27;game&#x27;;</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function nextLevel() {</div>
<div class="c2">+    // Advance to the next level</div>
<div class="c2">+    addMessage(&#x27;You take a moment to rest, and recover your strength.&#x27;, wglt.Colors.LIGHT_MAGENTA);</div>
<div class="c2">+    player.fighter.heal(player.fighter.maxHp / 2); // heal the player by 50%</div>
<div class="c2">+    dungeonLevel++;</div>
<div class="c2">+    addMessage(&#x27;After a rare moment of peace, you descend deeper...&#x27;, wglt.Colors.LIGHT_RED);</div>
<div class="c2">+    entities = [player];</div>
<div class="c2">+    map = createMap(); // Create a fresh new level!</div>
<div class="c2">+    fovMap = new wglt.FovMap(MAP_WIDTH, MAP_HEIGHT, (x, y) =&gt; map[y][x].blocked);</div>
<div class="c2">+    fovRecompute = true;</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function playGame() {</div>
<div class="c2">+    handleKeys();</div>
<div class="c2">+    renderAll();</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+function mainMenu() {</div>
<div class="c2">+    if (gui.dialogs.length === 0) {</div>
<div class="c2">+        const options = [&#x27;Play a new game&#x27;, &#x27;Continue last game&#x27;];</div>
<div class="c2">+        gui.add(new wglt.SelectDialog(&#x27;MAIN MENU&#x27;, options, (choice) =&gt; {</div>
<div class="c2">+            if (choice === 0) {</div>
<div class="c2">+                newGame();</div>
<div class="c2">+            } else if (choice === 1) {</div>
<div class="c2">+                loadGame();</div>
<div class="c2">+            }</div>
<div class="c2">+        }));</div>
<div class="c2">+    }</div>
<div class="c0"> </div>
<div class="c3">-// Initial FOV</div>
<div class="c3">-game.tileMap.computeFov(player.x, player.y, 12);</div>
<div class="c2">+    gui.handleInput();</div>
<div class="c0"> </div>
<div class="c3">-const mainMenu = new wglt.AppState(app);</div>
<div class="c3">-mainMenu.update = function () {</div>
<div class="c3">-    // Draw background</div>
<div class="c3">-    app.drawImage(0, 0, 0, 768, 400, 224);</div>
<div class="c3">-</div>
<div class="c3">-    // Draw menu</div>
<div class="c3">-    app.drawCenteredString(&#x27;NEW GAME&#x27;, app.center.x + 1, 100, wglt.Colors.BLACK);</div>
<div class="c3">-    app.drawCenteredString(&#x27;NEW GAME&#x27;, app.center.x, 101, wglt.Colors.BLACK);</div>
<div class="c3">-    app.drawCenteredString(&#x27;NEW GAME&#x27;, app.center.x + 1, 101, wglt.Colors.BLACK);</div>
<div class="c3">-    app.drawCenteredString(&#x27;NEW GAME&#x27;, app.center.x, 100, wglt.Colors.WHITE);</div>
<div class="c3">-</div>
<div class="c3">-    app.drawCenteredString(&#x27;CONTINUE&#x27;, app.center.x + 1, 120, wglt.Colors.BLACK);</div>
<div class="c3">-    app.drawCenteredString(&#x27;CONTINUE&#x27;, app.center.x, 121, wglt.Colors.BLACK);</div>
<div class="c3">-    app.drawCenteredString(&#x27;CONTINUE&#x27;, app.center.x + 1, 121, wglt.Colors.BLACK);</div>
<div class="c3">-    app.drawCenteredString(&#x27;CONTINUE&#x27;, app.center.x, 120, wglt.Colors.LIGHT_GRAY);</div>
<div class="c2">+    //app.clear();</div>
<div class="c0"> </div>
<div class="c3">-    if (app.isKeyPressed(wglt.Keys.VK_ENTER)) {</div>
<div class="c3">-        app.state = game;</div>
<div class="c2">+    if (menuBg) {</div>
<div class="c2">+        app.drawConsole(0, 0, menuBg, 0, 0, 80, 50);</div>
<div class="c2">+    }</div>
<div class="c2">+</div>
<div class="c2">+    app.drawCenteredString(40, 10, &#x27;TOMBS OF THE ANCIENT KINGS&#x27;, wglt.Colors.YELLOW);</div>
<div class="c2">+    app.drawCenteredString(40, 12, &#x27;By Jotaf&#x27;, wglt.Colors.YELLOW);</div>
<div class="c2">+    gui.draw();</div>
<div class="c2">+}</div>
<div class="c2">+</div>
<div class="c2">+const app = new wglt.App(document.querySelector(&#x27;canvas&#x27;), SCREEN_WIDTH, SCREEN_HEIGHT);</div>
<div class="c2">+const gui = new wglt.GUI(app);</div>
<div class="c2">+let rng = null;</div>
<div class="c2">+let player = null;</div>
<div class="c2">+let stairs = null;</div>
<div class="c2">+let entities = null;</div>
<div class="c2">+let messages = null;</div>
<div class="c2">+let dungeonLevel = 0;</div>
<div class="c2">+let map = null;</div>
<div class="c2">+let fovMap = null;</div>
<div class="c2">+let fovRecompute = true;</div>
<div class="c2">+let inventory = null;</div>
<div class="c2">+let targetFunction = null;</div>
<div class="c2">+let targetCursor = { x: 0, y: 0 };</div>
<div class="c2">+let appState = &#x27;menu&#x27;;</div>
<div class="c2">+let menuBg = null;</div>
<div class="c2">+</div>
<div class="c2">+wglt.loadImage2x(&#x27;menu.png&#x27;, (result) =&gt; { menuBg = result });</div>
<div class="c2">+</div>
<div class="c2">+app.update = function () {</div>
<div class="c2">+    switch (appState) {</div>
<div class="c2">+        case &#x27;menu&#x27;:</div>
<div class="c2">+            mainMenu();</div>
<div class="c2">+            break;</div>
<div class="c2">+</div>
<div class="c2">+        case &#x27;game&#x27;:</div>
<div class="c2">+            playGame();</div>
<div class="c2">+            break;</div>
<div class="c0">     }</div>
<div class="c0"> };</div>
<div class="c3">-</div>
<div class="c3">-// app.state = game;</div>
<div class="c3">-app.state = mainMenu;</div>
<!--ENDDIFF-->
    </div>
    <script src="../../dist/index.js"></script>
	<script src="part12.js"></script>
</body>

</html>
