const g=[-1,0,1,-1,1,-1,0,1],x=[-1,-1,-1,0,0,1,1,1],y=[1.4,1,1.4,1,1,1.4,1,1.4];let p=0;function f(r,e,t,l){p++;const o=r.grid[e.y][e.x];o.pathId=p,o.g=0,o.h=Math.hypot(e.x-t.x,e.y-t.y),o.prev=null;const s=new d([o]);for(;s.size()>0;){const n=s.pop();if(n.x===t.x&&n.y===t.y)return v(n);for(let h=0;h<g.length;h++){const c=n.x+g[h],u=n.y+x[h];if(c>=0&&c<r.width&&u>=0&&u<r.height){const i=r.grid[u][c];if(i.blocked&&i.explored&&(c!==t.x||u!==t.y))continue;i.pathId!==p&&(i.pathId=p,i.g=Number.POSITIVE_INFINITY,i.h=Math.hypot(c-t.x,u-t.y),i.prev=null);const a=n.g+y[h];a<i.g&&a<=l&&(i.g=a,i.prev=n,s.insert(i))}}}}function v(r){const e=[];let t=r;for(;t;)e.push(t),t=t.prev;return e.reverse(),e}class d{constructor(e){this.values=e}insert(e){const t=this.values;let l=0,o=t.length,s=0;for(;l<o;){const n=l+o>>>1,h=t[n];h.g+h.h>e.g+e.h?(l=n+1,s=l):(o=n,s=o)}t.splice(s,0,e)}pop(){return this.values.pop()}size(){return this.values.length}}export{f as c};
